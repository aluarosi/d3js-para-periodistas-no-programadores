{
  "author": {
    "name": "Mark Cavage",
    "email": "mcavage@gmail.com"
  },
  "contributors": [
    {
      "name": "Mike Harsch"
    },
    {
      "name": "Nate Fitch"
    },
    {
      "name": "Yunong Xiao"
    },
    {
      "name": "Patrick Mooney"
    }
  ],
  "name": "fast",
  "homepage": "http://mcavage.github.com/node-fast",
  "version": "0.4.1",
  "repository": {
    "type": "git",
    "url": "git://github.com/mcavage/node-fast.git"
  },
  "main": "lib/index.js",
  "engines": {
    "node": ">=0.8.22"
  },
  "dependencies": {
    "assert-plus": "0.1.5",
    "backoff": "2.4.0",
    "crc": "0.2.1",
    "microtime": "1.0.1",
    "once": "1.3.0",
    "readable-stream": "1.1.10",
    "verror": "1.3.6",
    "dtrace-provider": "0.3.0"
  },
  "optionalDependencies": {
    "dtrace-provider": "0.3.0"
  },
  "devDependencies": {
    "tape": "2.14.0",
    "faucet": "0.0.1",
    "istanbul": "0.3.0"
  },
  "scripts": {
    "report": "istanbul report html && open ./coverage/lcov-report/index.html",
    "test": "istanbul cover --print none test/test.js | ./node_modules/.bin/faucet"
  },
  "readme": "`fast` is a very small JSON over TCP messaging framework.  Effectively, it lets\nyou write RPC systems that \"stream\" many results back for a single message (not in\nthe sense of a streaming JSON parser, but in the sense of many objects that are\ncorrelated).  For example:\n\n    var fast = require('fast');\n    var server = fast.createServer();\n\n    server.rpc('echo', function (fname, lname, res) {\n\t    res.write({first: fname});\n\t\tres.end({last: lname});\n    });\n\n\tserver.listen(1234);\n\n    /// Client\n    var client = fast.createClient({host: 'localhost', port: 1234});\n\tclient.on('connect', function () {\n\t    var req = client.rpc('echo', 'mark', 'cavage');\n\t\treq.on('message', function (obj) {\n\t\t    console.log(JSON.stringify(obj, null, 2));\n        });\n\t\treq.on('end', function () {\n\t\t    client.close();\n\t\t\tserver.close();\n        });\n    });\n\n\nWhile does what you think it does.  A few things to note:\n\n* There's a \"gentlemen's agreement\" in argument reconstruction.  Whatever you\n  pass client side as arguments shows up, in that order, server side.  So in\n  the example above, note that `server.rpc('echo', function (f, l, res) {})`,\n  gave us the client's set of strings and a `res` object you use to kick back\n  results on as the last argument.  It just does that.\n* Whatever you send back server side shows up on the client `.on('message')`\n  the same as the server.  So above, I sent back an object, but you can send\n  back anything, and the arguments will \"line up\".\n* Server-side, you can send data either via write or end (as above).  Also, if\n  you pass something that `instanceof Error` returns true on, that gets\n  spit out as a `req.on('error', function (err) {})` client-side.\n\nThat's pretty much it.  This needs a lot more docs, but for now, I'm throwing\nthis up on github as-is, and I'll add more over time.\n\n# Installation\n\n    npm install fast\n\n# Protocol\n\nBasically, I cooked a small header+data payload like this:\n\n```\nByte/     0       |       1       |       2       |       3       |\n   /              |               |               |               |\n  |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|\n  +---------------+---------------+---------------+---------------+\n 0|Version        |Type           |Status         |MessageID\n  +---------------+---------------+---------------+---------------+\n 4|                                               |CRC16\n  +---------------+---------------+---------------+---------------+\n 8|                                               |DataLen\n  +---------------+---------------+---------------+---------------+\n12|                                               |Data...\n  +---------------+---------------+---------------+---------------+\n16|...\n```\n\nWhere:\n\n* Version: Currently always `0x01`\n* Type: Currently always `0x01` (Means JSON -> may add GZIP JSON, etc., later)\n* Status: An enum to reflect the what this message is in the sequence:\n** 0x01: `data`: More messages to come\n** 0x02: `end`: No more messages to come (All is well)\n** 0x03: `error`: No more messages to come; error returned from server in `data`\n* MessageID: A 32-bit UInt32 (big endian encoded) from 1 - (2^32 âˆ’ 1).  A client\n  sets this initially, and all messages returned from the server to the client\n  that correspond to the request must carry the same messageID.\n* CRC16: CRC16 of the data, encoded as a 32bit signed integer (big endian)\n* DataLen: 32-bit UInt32, encoded big endian.\n* Data: JSON-encoded data payload.\n\nOn top of that, there is \"moar gentlemenly agreement\" of what \"data\" looks like\nto facilitate RPC.  Basically, `data` is a JSON object like this:\n\n    {\n\t    m: {\n\t\t    name: 'echo',\n\t\t\tuts: gettimeofday(2) // microseconds since epoch\n        },\n\t\td: [] // \"arguments\" to JS function\n    }\n\nThat's pretty much it.  Note there is effectively no try/catch or anything like\nthat in this framework, as it's intended to be run \"carefully\".  If it's too\nproblematic I'll add that, but clearly this is meant to do one thing: go fast\nfrom internal service A to internal service B.  YMMV.\n# Licence\n\nMIT\n",
  "readmeFilename": "README.md",
  "description": "`fast` is a very small JSON over TCP messaging framework.  Effectively, it lets you write RPC systems that \"stream\" many results back for a single message (not in the sense of a streaming JSON parser, but in the sense of many objects that are correlated).  For example:",
  "bugs": {
    "url": "https://github.com/mcavage/node-fast/issues"
  },
  "_id": "fast@0.4.1",
  "_shasum": "4fb1c6aa287f79c9b15244f5ea1eae981b097d8c",
  "_from": "fast@0.4.1",
  "_resolved": "https://registry.npmjs.org/fast/-/fast-0.4.1.tgz"
}
