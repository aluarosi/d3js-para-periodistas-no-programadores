{
  "name": "jsprim",
  "version": "0.6.1",
  "description": "utilities for primitive JavaScript types",
  "main": "./lib/jsprim.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/davepacheco/node-jsprim.git"
  },
  "dependencies": {
    "extsprintf": "1.0.2",
    "json-schema": "0.2.2",
    "verror": "1.3.6"
  },
  "engines": [
    "node >=0.6.0"
  ],
  "license": "MIT",
  "readme": "# jsprim: utilities for primitive JavaScript types\n\nThis module provides miscellaneous facilities for working with strings,\nnumbers, dates, and objects and arrays of these basic types.\n\n\n### deepCopy(obj)\n\nCreates a deep copy of a primitive type, object, or array of primitive types.\n\n\n### deepEqual(obj1, obj2)\n\nReturns whether two objects are equal.\n\n\n### isEmpty(obj)\n\nReturns true if the given object has no properties and false otherwise.  This\nis O(1) (unlike `Object.keys(obj).length === 0`, which is O(N)).\n\n\n### forEachKey(obj, callback)\n\nLike Array.forEach, but iterates properties of an object rather than elements\nof an array.  Equivalent to:\n\n    for (var key in obj)\n            callback(key, obj[key]);\n\n\n### flattenObject(obj, depth)\n\nFlattens an object up to a given level of nesting, returning an array of arrays\nof length \"depth + 1\", where the first \"depth\" elements correspond to flattened\ncolumns and the last element contains the remaining object .  For example:\n\n    flattenObject({\n        'I': {\n            'A': {\n                'i': {\n                    'datum1': [ 1, 2 ],\n                    'datum2': [ 3, 4 ]\n                },\n                'ii': {\n                    'datum1': [ 3, 4 ]\n                }\n            },\n            'B': {\n                'i': {\n                    'datum1': [ 5, 6 ]\n                },\n                'ii': {\n                    'datum1': [ 7, 8 ],\n                    'datum2': [ 3, 4 ],\n                },\n                'iii': {\n                }\n            }\n        },\n        'II': {\n            'A': {\n                'i': {\n                    'datum1': [ 1, 2 ],\n                    'datum2': [ 3, 4 ]\n                }\n            }\n        }\n    }, 3)\n\nbecomes:\n\n    [\n        [ 'I',  'A', 'i',   { 'datum1': [ 1, 2 ], 'datum2': [ 3, 4 ] } ],\n        [ 'I',  'A', 'ii',  { 'datum1': [ 3, 4 ] } ],\n        [ 'I',  'B', 'i',   { 'datum1': [ 5, 6 ] } ],\n        [ 'I',  'B', 'ii',  { 'datum1': [ 7, 8 ], 'datum2': [ 3, 4 ] } ],\n        [ 'I',  'B', 'iii', {} ],\n        [ 'II', 'A', 'i',   { 'datum1': [ 1, 2 ], 'datum2': [ 3, 4 ] } ]\n    ]\n\nThis function is strict: \"depth\" must be a non-negative integer and \"obj\" must\nbe a non-null object with at least \"depth\" levels of nesting under all keys.\n\n\n### flattenIter(obj, depth, func)\n\nThis is similar to `flattenObject` except that instead of returning an array,\nthis function invokes `func(entry)` for each `entry` in the array that\n`flattenObject` would return.  `flattenIter(obj, depth, func)` is logically\nequivalent to `flattenObject(obj, depth).forEach(func)`.  Importantly, this\nversion never constructs the full array.  Its memory usage is O(depth) rather\nthan O(n) (where `n` is the number of flattened elements).\n\nThere's another difference between `flattenObject` and `flattenIter` that's\nrelated to the special case where `depth === 0`.  In this case, `flattenObject`\nomits the array wrapping `obj` (which is regrettable).\n\n\n### pluck(obj, key)\n\nFetch nested property \"key\" from object \"obj\", traversing objects as needed.\nFor example, `pluck(obj, \"foo.bar.baz\")` is roughly equivalent to\n`obj.foo.bar.baz`, except that:\n\n1. If traversal fails, the resulting value is undefined, and no error is\n   thrown.  For example, `pluck({}, \"foo.bar\")` is just undefined.\n2. If \"obj\" has property \"key\" directly (without traversing), the\n   corresponding property is returned.  For example,\n   `pluck({ 'foo.bar': 1 }, 'foo.bar')` is 1, not undefined.  This is also\n   true recursively, so `pluck({ 'a': { 'foo.bar': 1 } }, 'a.foo.bar')` is\n   also 1, not undefined.\n\n\n### randElt(array)\n\nReturns an element from \"array\" selected uniformly at random.  If \"array\" is\nempty, throws an Error.\n\n\n### startsWith(str, prefix)\n\nReturns true if the given string starts with the given prefix and false\notherwise.\n\n\n### endsWith(str, suffix)\n\nReturns true if the given string ends with the given suffix and false\notherwise.\n\n\n### iso8601(date)\n\nConverts a Date object to an ISO8601 date string of the form\n\"YYYY-MM-DDTHH:MM:SS.sssZ\".  This format is not customizable.\n\n\n### parseDateTime(str)\n\nParses a date expressed as a string, as either a number of milliseconds since\nthe epoch or any string format that Date accepts, giving preference to the\nformer where these two sets overlap (e.g., strings containing small numbers).\n\n\n### validateJsonObject(schema, object)\n\nUses JSON validation (via JSV) to validate the given object against the given\nschema.  On success, returns null.  On failure, *returns* (does not throw) a\nuseful Error object.\n\n\n# Contributing\n\nCode should be \"make check\" clean.  This target assumes that\n[jsl](http://github.com/davepacheco/javascriptlint) and\n[jsstyle](http://github.com/davepacheco/jsstyle) are on your path.\n\nNew tests should generally accompany new functions and bug fixes.  The tests\nshould pass cleanly (run tests/basic.js).\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/davepacheco/node-jsprim/issues"
  },
  "homepage": "https://github.com/davepacheco/node-jsprim",
  "_id": "jsprim@0.6.1",
  "_shasum": "124c5b5aee1d03845206140b6594a2df63df4477",
  "_from": "jsprim@0.6.1",
  "_resolved": "https://registry.npmjs.org/jsprim/-/jsprim-0.6.1.tgz"
}
